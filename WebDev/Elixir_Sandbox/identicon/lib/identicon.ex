defmodule Identicon do
  @moduledoc """
    Documentation for Identicon.
  """
  def main(input) do
    input
    |> hash_input
    |> pick_color
    |> make_grid
    |> filter_squares
    |> build_pixel_map
    |> draw_image
    |> save_image(input)
  end


  @doc """
    Runs input string through MD5 hashing algorithm using the `:crypto` library. `binary.bin_to_list` converts the resulting hashed string into a list of numbers.
    The result is passed to the function `pick_color`.
  """
  def hash_input(input) do
    hex = :crypto.hash(:md5, input)
    |> :binary.bin_to_list

    %Identicon.Image{seed: hex}
  end

  @doc """
    Uses the first three values of the resulting list from function `hash_input` to determine the RGB value for the identicon color.
  """
  def pick_color(image) do
    %Identicon.Image{seed: [r, g, b | _tail]} = image
    %Identicon.Image{image | rgb: {r, g, b}}
  end

  @doc """
    Separates the values of our `%Identicon.Image{seed}` into 3 member tuples using `Enum.chunk_every/4`. Each of these tuples is then expanded by "mirroring" the first two values around the third using `Identicon.mirror_row/1`. Thus, each tuple is in a 12321 pattern. The list of tuples is then flattened for easier parsing by `Identicon.filter_squares/1` and a new version of the `Image` struct is created.
  """
  def make_grid(image) do
    %Identicon.Image{seed: value} = image
    graph =
      value
      |> Enum.chunk_every(3, 3, :discard)
      |> Enum.map(&mirror_row/1)
      |> List.flatten
      |> Enum.with_index
      %Identicon.Image{image | grid: graph}
  end

  @doc """
    A helper function for mirroring a 3-member tuple around the third member. The resulting tuple contains 5 members in a 12321 pattern.
  """
  def mirror_row(row) do
    [first, second, _third] = row
    row ++ [second, first]
  end

  @doc """
    Parses the `grid` value of the `Image` struct passed in such that all tuples containing odd numbers as their first value are filtered out. The resulting list of tuples is used to determine which squares within our resulting identicon grid are to be colored.
  """
  def filter_squares(%Identicon.Image{grid: grid} = image) do
    colorgrid =
      Enum.filter grid, fn({value, _index}) ->
        rem(value,2) == 0
      end
    %Identicon.Image{image| colorgrid: colorgrid}
  end

  @doc """
   The list of filtered tuples from `Identicon.filter_squares/1` is used to determine the position of colored squares within the resultant identicon. Specifically, the second value of each tuple, the original list index of that tuple, is processed to determine the starting (top left) and endind (bottom right) points of its corresponding square in the identicon. The result is a list of coordinates that represent a map of colored pixels.
  """
  def build_pixel_map(%Identicon.Image{colorgrid: colorgrid} = image) do
    pixelmap = Enum.map colorgrid, fn({_value, index}) ->

      horizontal = rem(index, 5) * 50
      vertical = div(index, 5) * 50

      top_left = {horizontal, vertical}
      bottom_right = {horizontal + 50, vertical + 50}

      {top_left, bottom_right}
    end
    %Identicon.Image{image | pixelmap: pixelmap}
  end

  @doc """
    Utilizes `Erlang Graphical Drawer` to create an image canvas and populate it with colored squares matching the size and hue calculated in `filter_squares` and `build_pixel_map`. Image is drawn to memory.
  """
  def draw_image(%Identicon.Image{rgb: color, pixelmap: pixelmap}) do
    canvas = :egd.create(250,250)
    paint = :egd.color(color)

    Enum.map pixelmap, fn({start, stop})->
      :egd.filledRectangle(canvas, start, stop, paint)
    end
    :egd.render(canvas)
  end

  @doc """
    Saves the image generated by `draw_image` to disc
  """
  def save_image(image, input) do
    File.write("#{input}.png", image)
  end
end
